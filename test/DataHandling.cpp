// Standard
#include <iostream>
#include <fstream>
#include <sstream>
#include <string>

// Boost
#define BOOST_TEST_MAIN
#define BOOST_THROW_EXCEPTIONS
#include <boost/test/unit_test.hpp>
#include <boost/program_options.hpp>
#include <boost/filesystem.hpp>
#include <boost/property_tree/ptree.hpp>

// Class
#include "Base.hpp"
#include "Data.hpp"

// namespace
namespace po = boost::program_options;
namespace fs = boost::filesystem;
namespace pt = boost::property_tree;

/*
 * Prints property tree
 */
void printTree(const pt::ptree& tree) {
    std::ostringstream oss;
    pt::write_json(oss, tree);
    std::cout << oss.str() << std::endl;
}

/*
 * Checks if a string is a subset of another string
 */
bool isSubpath(const std::string& subpath, const std::string& superpath) {
    // check if subpath is a subset of superpath
    return superpath.find(subpath) != std::string::npos;
}

void processDataStructure(const std::string& readtype, pt::ptree& tree,
                          std::vector<std::string>& input,
                          std::vector<std::string>& output,
                          std::vector<std::string>& conds) {

    for (auto &elem: tree) {
        conds.push_back(elem.second.get<std::string>("condition"));
        pt::ptree samples = elem.second.get_child("samples");

        for(auto& sample : samples) {
            input.push_back(sample.second.get<std::string>("input.forward"));
            output.push_back(sample.second.get<std::string>("output.forward"));

            if(readtype == "PE") {
                input.push_back(sample.second.get<std::string>("input.reverse"));
                output.push_back(sample.second.get<std::string>("R1only"));
                output.push_back(sample.second.get<std::string>("R2only"));
                output.push_back(sample.second.get<std::string>("R1unmerged"));
                output.push_back(sample.second.get<std::string>("R2unmerged"));
            }
        }
    }
}

/*
 * Compares the data structure files (.json) generated by the data class
 */
bool compareDataStructureFiles(const fs::path& ref, const fs::path& gen, std::string& subcall, std::string& readtype) {
    std::ifstream ifref(ref.string());
    std::ifstream ifgen(gen.string());
    pt::ptree pref, pgen;
    pt::read_json(ifref, pref); // load file into property tree
    pt::read_json(ifgen, pgen); // load file into property tree
    ifref.close();
    ifgen.close();

    std::map<std::string, std::pair<pt::ptree, pt::ptree>> dataStructure;
    dataStructure.insert(std::make_pair("ctrls", std::make_pair(
                pref.get_child(subcall).get_child("ctrls"),
                pgen.get_child(subcall).get_child("ctrls")
            )));
    dataStructure.insert(std::make_pair("trtms", std::make_pair(
                pref.get_child(subcall).get_child("trtms"),
                pgen.get_child(subcall).get_child("trtms")
            )));

    // reference/generate for comparison (first = reference, second = generated)
    std::pair<std::vector<std::string>, std::vector<std::string>> conds;
    std::pair<std::vector<std::string>, std::vector<std::string>> input, output;

    for(auto& readtype : dataStructure) { // iterate through
        pt::ptree &treeP1 = readtype.second.first; // reference (ground truth)
        pt::ptree &treeP2 = readtype.second.second; // generated file for testing

        processDataStructure(readtype.first, treeP1, input.first, output.first, conds.first);
        processDataStructure(readtype.first, treeP2, input.second, output.second, conds.second);

    }

    BOOST_TEST_CONTEXT("Testing if conditions in the input files (subfolders in ctrls, trtms) have been identified correctly") {
        BOOST_CHECK_EQUAL(conds.first.size(), conds.second.size());
        BOOST_TEST_MESSAGE("reference: " << conds.first.size() << "\ngenerated: " << conds.second.size() << "\nThis counts conditions in ctrls and trtms separately");
        // check if condition vectors are equal
        BOOST_CHECK_EQUAL_COLLECTIONS(conds.first.begin(), conds.first.end(), conds.second.begin(), conds.second.end());
        for(unsigned int i = 0; i < conds.first.size(); i++) {
            std::cout << conds.first[i] <<  " == " << conds.second[i] << "\n";
        }
    }

    BOOST_TEST_CONTEXT("Testing if the input files have been identified correctly") {
        BOOST_CHECK_EQUAL(input.first.size(), input.second.size());
        BOOST_TEST_MESSAGE("number of reference input files: " << input.first.size() << "\nnumber of generated input files: " << input.second.size());
        for(unsigned int i = 0; i < input.first.size(); i++) {
            BOOST_CHECK(isSubpath(input.first[i], input.second[i]));
        }
    }

    BOOST_TEST_CONTEXT("Testing if the output files have been identified correctly") {
        BOOST_CHECK_EQUAL(input.first.size(), input.second.size());
        BOOST_TEST_MESSAGE("number of reference output files: " << input.first.size() << "\nnumber of generated output files: " << input.second.size());
        for(unsigned int i = 0; i < input.first.size(); i++) {
            BOOST_CHECK(isSubpath(input.first[i], input.second[i]));
        }
    }

    return true;
}

BOOST_AUTO_TEST_CASE(DataHandlingPreprocSE) {
    fs::path testdir{fs::path(__FILE__).parent_path()};
    fs::path outdir{testdir / "data" / "datahandling" / "results_SE"}; // test-outdir
    fs::path ctrls{testdir / "data" / "datahandling" / "rawreads_SE" / "ctrls"}; // test-ctrls
    fs::path trtms{testdir / "data" / "datahandling" / "rawreads_SE" / "trtms"}; // test-trtms

    // Inserting dummy key-value pairs
    po::variables_map params;
    params.insert(std::make_pair("ctrls", po::variable_value(ctrls.string(), false)));
    params.insert(std::make_pair("trtms", po::variable_value(trtms.string(), false)));
    params.insert(std::make_pair("outdir", po::variable_value(outdir.string(), false)));
    params.insert(std::make_pair("readtype", po::variable_value(std::string("SE"), false)));
    params.insert(std::make_pair("subcall", po::variable_value(std::string("preproc"), false)));

    // Create Data Object
    Data data(params);

    // compare files
    fs::path ref{testdir / "data" / "datahandling" / "dataPreprocSE.json"}; // ground truth
    fs::path res{outdir / "data.json"}; // generated data file

    std::string subcall = "preproc";
    std::string readtype = "SE";
    compareDataStructureFiles(ref, res, subcall, readtype);
}

BOOST_AUTO_TEST_CASE(DataHandlingPreprocPE) {
    fs::path testdir{fs::path(__FILE__).parent_path()};
    fs::path outdir{testdir / "data" / "datahandling" / "results_PE"}; // test-outdir
    fs::path ctrls{testdir / "data" / "datahandling" / "rawreads_PE" / "ctrls"}; // test-ctrls
    fs::path trtms{testdir / "data" / "datahandling" / "rawreads_PE" / "trtms"}; // test-trtms

    // Inserting dummy key-value pairs
    po::variables_map params;
    params.insert(std::make_pair("ctrls", po::variable_value(ctrls.string(), false)));
    params.insert(std::make_pair("trtms", po::variable_value(trtms.string(), false)));
    params.insert(std::make_pair("outdir", po::variable_value(outdir.string(), false)));
    params.insert(std::make_pair("readtype", po::variable_value(std::string("PE"), false)));
    params.insert(std::make_pair("subcall", po::variable_value(std::string("preproc"), false)));

    // Create Data Object
    Data data(params);

    // compare files
    fs::path ref{testdir / "data" / "datahandling" / "dataPreprocPE.json"}; // ground truth
    fs::path res{outdir / "data.json"}; // generated data file
    std::string subcall = "preproc";
    std::string readtype = "PE";
    compareDataStructureFiles(ref, res, subcall, readtype);
}
